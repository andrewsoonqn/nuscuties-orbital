# Design Decision: Dual-Method Status Effect Application in StatusEffectManager

## Overview
In the implementation of our status effect system for the NUSCuties game, we faced the challenge of how to apply status effects to characters in a flexible, maintainable, and efficient manner. The core requirement was to allow both simple, standardized application of status effects (e.g., default burn or slow) and more customized instances where parameters like damage or duration might need adjustment based on weapon stats or game events. After evaluating several approaches, we settled on a hybrid design in the `StatusEffectManager` class that provides two complementary methods: a generic factory method `ApplyStatusEffect<T>()` for quick, type-safe creation of standard effects, and a direct object-passing method `ApplyStatusEffect(StatusEffect effect)` for maximum flexibility with custom configurations.

## Approaches Tried and Comparisons
Initially, we considered a single method that always required manual instantiation, such as `ApplyStatusEffect(new BurnStatusEffect())`. This approach was straightforward but verbose, especially for standard effects without custom parameters—it forced callers to handle object creation every time, potentially leading to code duplication and unnecessary memory allocation if an effect was replaced immediately due to our anti-stacking logic. We also briefly explored a pure factory pattern without the direct method, but this limited flexibility for cases needing constructor parameters or runtime configuration.

The hybrid approach we adopted addresses these shortcomings effectively. Compared to the manual-only method, the generic factory reduces boilerplate for common cases (e.g., `ApplyStatusEffect<BurnStatusEffect>()` vs. manual `new` and pass), improving readability and reducing errors. It also encapsulates creation logic, ensuring consistent instantiation. Versus a factory-only design, the direct method allows passing pre-configured objects, enabling scenarios like varying burn damage based on weapon level (e.g., `var burn = new BurnStatusEffect(); burn._damagePerTick = 10; ApplyStatusEffect(burn);`). This makes the system more adaptable to future expansions, such as status effects with complex initialization, while the old single-method approaches would require workarounds like additional setter methods or subclasses.

Why is this better? The old manual-only approach violated the Don't Repeat Yourself (DRY) principle by repeating instantiation code across the codebase, and it was less performant due to potential wasted allocations. A factory-only design would have been too rigid, forcing all customizations through generics or parameters, which could complicate the API. Our hybrid strikes an optimal balance: it's concise for 80% of use cases (standard effects) while remaining extensible for advanced scenarios, resulting in cleaner, more maintainable code with better performance in high-frequency combat situations.

## Relevant SOLID Principles
This design adheres to several SOLID principles, enhancing the system's modularity and extensibility.

### Single Responsibility Principle (SRP)
Abstractly, SRP dictates that a class should have only one reason to change. In our case, the `StatusEffectManager` is solely responsible for managing the lifecycle of status effects on a character, including application, duplicate checking, and removal. Concretely, the dual methods centralize this responsibility: the generic `ApplyStatusEffect<T>()` handles creation as a convenience, but delegates to the core `ApplyStatusEffect(StatusEffect)` method, which performs the actual management logic like checking for existing effects (`var existingEffect = _activeEffects.FirstOrDefault(...)`) and wiring up cleanup (`effect.TreeExiting += ...`). This separation ensures that if we need to change how effects are instantiated (e.g., add pooling), only the factory method changes, while the management logic remains isolated.

### Open-Closed Principle (OCP)
OCP states that software entities should be open for extension but closed for modification. Our design exemplifies this by allowing new status effect types to be added without modifying the manager: simply create a new class inheriting from `StatusEffect` (e.g., `PoisonStatusEffect`), and it can be applied via either method without touching `StatusEffectManager`. For instance, extending with a new effect involves no changes to the application methods—the generic factory uses the `new()` constraint to instantiate any compliant type, and the direct method accepts any `StatusEffect` subclass. This closed-for-modification aspect prevents ripple effects when adding features like new elemental effects.

### Liskov Substitution Principle (LSP)
LSP requires that subclasses be substitutable for their base classes without altering program behavior. All status effects derive from the abstract `StatusEffect` base, implementing shared methods like `Apply()`, `Remove()`, and `OnTick()`. This allows the manager to treat them uniformly (e.g., storing in `_activeEffects` as `List<StatusEffect>`), regardless of specific type. Concretely, when applying via the direct method, a `BurnStatusEffect` can be passed as a `StatusEffect`, and the manager's logic (e.g., type checking with `e.GetType() == effect.GetType()`) works identically for any subclass, ensuring behavioral consistency.

## Applicable Design Patterns
### Factory Method Pattern
We employ the Factory Method pattern in the generic `ApplyStatusEffect<T>()`, where the method acts as a factory for creating status effect instances. Abstractly, this pattern defines an interface for creating objects but lets subclasses decide which class to instantiate. In our concrete implementation, the manager serves as the creator, using generics to produce the correct type (`var effect = new T();`) before passing to the core application logic. This is particularly useful in the hitbox collision handler, where we can simply call `target.StatusEffects.ApplyStatusEffect<BurnStatusEffect>()` without knowing instantiation details, promoting loose coupling between the weapon system and status effects.

### Strategy Pattern (Implicit)
While not explicitly a strategy, the way status effects encapsulate their behavior (`OnApplied()`, `OnTick()`, `OnRemoved()`) follows strategy-like encapsulation. Each effect is a "strategy" for how to modify character state over time, and the manager composes them dynamically. Concretely, this allows swapping effects (e.g., burn vs. slow) without changing the manager's code, as seen in the hitbox's `ApplyStatusEffect` switch statement, which selects the strategy based on the weapon's `statusEffect` string.

This design decision positions our status effect system for long-term maintainability, aligning with the game's need for expandable RPG mechanics while keeping the codebase clean and performant.
